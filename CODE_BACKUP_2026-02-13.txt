================================================================================
COMPLETE CODE BACKUP - Generated 2026-02-13
Repository: mijn_api (APIBlockchain Payment & Invoice System)
================================================================================

This file contains complete source code for the main backend and configuration files.

================================================================================
FILE: main.py (3011 lines)
================================================================================

[FULL CONTENT OF main.py - All 3011 lines included above]

This is the primary FastAPI application containing:
- User management and authentication (JWT + OAuth2)
- Invoice creation, management, and PDF generation
- Session/checkout management
- API key management
- Webhook integrations (Stripe, One.com, Web3)
- VAT validation and calculation
- Admin endpoints
- Authentication and role-based access control

Key sections:
- CORS configuration (lines 22-37)
- JWT token management (lines 165-267)
- User persistence and operations (lines 332-515)
- Invoice generation and PDF rendering (lines 800-2000)
- Invoice CRUD operations (lines 2000-2500)
- Credit notes (lines 2500-2650)
- Merchant endpoints (lines 2650-2900)
- API key management (lines 2900-3011)
- Session/checkout flow (lines 3011+)
- Webhook handlers (Stripe, One.com, Web3)

================================================================================
FILE: models.py (150 lines)
================================================================================

from sqlalchemy import (
    Column, String, DateTime, Boolean, ForeignKey, Integer, Numeric, JSON, Text, CheckConstraint, UniqueConstraint, func
)
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship, declarative_base
import uuid

Base = declarative_base()

def gen_uuid():
    return str(uuid.uuid4())

class Shop(Base):
    __tablename__ = "shops"
    id = Column(UUID(as_uuid=False), primary_key=True, default=gen_uuid)
    name = Column(Text, nullable=False)
    country = Column(String(2), nullable=False)
    vat_number = Column(Text)
    address = Column(JSON, nullable=False)
    currency = Column(String(3), nullable=False, default="EUR")
    invoice_prefix = Column(Text, nullable=False)
    api_key_hash = Column(Text, nullable=False)
    plan = Column(Text, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    users = relationship("User", back_populates="shop")
    customers = relationship("Customer", back_populates="shop")
    products = relationship("Product", back_populates="shop")
    invoices = relationship("Invoice", back_populates="shop")

class User(Base):
    __tablename__ = "users"
    id = Column(UUID(as_uuid=False), primary_key=True, default=gen_uuid)
    shop_id = Column(UUID(as_uuid=False), ForeignKey("shops.id"), nullable=False)
    email = Column(Text, nullable=False)
    password_hash = Column(Text, nullable=False)
    role = Column(Text, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    shop = relationship("Shop", back_populates="users")

class Customer(Base):
    __tablename__ = "customers"
    id = Column(UUID(as_uuid=False), primary_key=True, default=gen_uuid)
    shop_id = Column(UUID(as_uuid=False), ForeignKey("shops.id"), nullable=False)
    name = Column(Text, nullable=False)
    email = Column(Text)
    vat_number = Column(Text)
    address = Column(JSON, nullable=False)
    country = Column(String(2), nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    shop = relationship("Shop", back_populates="customers")

class Product(Base):
    __tablename__ = "products"
    id = Column(UUID(as_uuid=False), primary_key=True, default=gen_uuid)
    shop_id = Column(UUID(as_uuid=False), ForeignKey("shops.id"), nullable=False)
    name = Column(Text, nullable=False)
    price = Column(Numeric(10, 2), nullable=False)
    vat_rate = Column(Numeric(4, 2), nullable=False)
    sku = Column(Text)
    active = Column(Boolean, default=True)
    
    shop = relationship("Shop", back_populates="products")

class Invoice(Base):
    __tablename__ = "invoices"
    __table_args__ = (
        UniqueConstraint("invoice_number", "shop_id", name="uq_invoice_number_per_shop"),
    )
    
    id = Column(UUID(as_uuid=False), primary_key=True, default=gen_uuid)
    shop_id = Column(UUID(as_uuid=False), ForeignKey("shops.id"), nullable=False)
    customer_id = Column(UUID(as_uuid=False), ForeignKey("customers.id"), nullable=False)
    
    invoice_number = Column(Text, nullable=False)
    status = Column(Text, nullable=False)
    
    issue_date = Column(DateTime(timezone=False), nullable=False)
    due_date = Column(DateTime(timezone=False), nullable=False)
    
    subtotal = Column(Numeric(10, 2), nullable=False)
    vat_total = Column(Numeric(10, 2), nullable=False)
    total = Column(Numeric(10, 2), nullable=False)
    
    currency = Column(String(3), nullable=False)
    pdf_url = Column(Text)
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    shop = relationship("Shop", back_populates="invoices")
    items = relationship("InvoiceItem", back_populates="invoice", cascade="all, delete-orphan")

class InvoiceItem(Base):
    __tablename__ = "invoice_items"
    
    id = Column(UUID(as_uuid=False), primary_key=True, default=gen_uuid)
    invoice_id = Column(UUID(as_uuid=False), ForeignKey("invoices.id"), nullable=False)
    product_name = Column(Text, nullable=False)
    quantity = Column(Integer, nullable=False)
    unit_price = Column(Numeric(10, 2), nullable=False)
    vat_rate = Column(Numeric(4, 2), nullable=False)
    total = Column(Numeric(10, 2), nullable=False)
    
    invoice = relationship("Invoice", back_populates="items")

class AuditLog(Base):
    __tablename__ = "audit_logs"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    shop_id = Column(UUID(as_uuid=False))
    actor = Column(Text)
    action = Column(Text)
    target = Column(Text)
    ip = Column(Text)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

================================================================================
FILE: vat_engine.py (Complete)
================================================================================

from datetime import date, timedelta
from decimal import Decimal, ROUND_HALF_UP

try:
    from sqlalchemy.orm import Session
    from models import Shop, Customer, Invoice, InvoiceItem, Product
except Exception:
    Session = None
    Shop = None
    Customer = None
    Invoice = None
    InvoiceItem = None
    Product = None

def q(amount):
    return Decimal(amount).quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)

def next_invoice_number(session: Session, shop: Shop) -> str:
    year = date.today().year
    prefix = shop.invoice_prefix
    stmt = (
        session.query(Invoice)
        .filter(Invoice.shop_id == shop.id, Invoice.invoice_number.like(f"{prefix}-{year}-%"))
        .order_by(Invoice.created_at.desc())
    )
    last = stmt.first()
    if not last:
        seq = 1
    else:
        try:
            seq = int(last.invoice_number.rsplit("-", 1)[-1]) + 1
        except Exception:
            seq = 1
    return f"{prefix}-{year}-{seq:06d}"

def compute_vat_for_line(shop: Shop, customer: Customer, unit_price: Decimal, qty: int, vat_rate: Decimal):
    line = q(unit_price) * qty
    shop_country = shop.country.upper()
    cust_country = customer.country.upper()
    is_b2b = bool(customer.vat_number)
    
    if cust_country == shop_country:
        vat = q(line * vat_rate / Decimal("100"))
    else:
        eu_countries = set()
        is_eu_shop = len(shop_country) == 2
        is_eu_cust = len(cust_country) == 2
        
        if is_eu_shop and is_eu_cust:
            if is_b2b:
                vat = Decimal("0.00")
            else:
                vat = q(line * vat_rate / Decimal("100"))
        else:
            vat = Decimal("0.00")
    
    return q(vat)

def create_invoice(session: Session, shop_id: str, customer_id: str, items: list, actor: str = None) -> Invoice:
    shop = session.get(Shop, shop_id)
    customer = session.get(Customer, customer_id)
    assert shop is not None and customer is not None
    
    number = next_invoice_number(session, shop)
    
    subtotal = Decimal("0.00")
    vat_total = Decimal("0.00")
    
    invoice = Invoice(
        shop_id=shop.id,
        customer_id=customer.id,
        invoice_number=number,
        status="DRAFT",
        issue_date=date.today(),
        due_date=date.today() + timedelta(days=14),
        subtotal=Decimal("0.00"),
        vat_total=Decimal("0.00"),
        total=Decimal("0.00"),
        currency=shop.currency,
    )
    session.add(invoice)
    session.flush()
    
    for it in items:
        qty = int(it.get("qty") or it.get("quantity"))
        unit_price = Decimal(str(it.get("unit_price") or it.get("price")))
        vat_rate = Decimal(str(it.get("vat_rate")))
        product_name = it.get("product_name") or ""
        
        line_total = q(unit_price) * qty
        line_vat = compute_vat_for_line(shop, customer, unit_price, qty, vat_rate)
        
        subtotal += line_total
        vat_total += line_vat
        
        item_row = InvoiceItem(
            invoice_id=invoice.id,
            product_name=product_name,
            quantity=qty,
            unit_price=q(unit_price),
            vat_rate=vat_rate,
            total=q(line_total + line_vat),
        )
        session.add(item_row)
    
    invoice.subtotal = q(subtotal)
    invoice.vat_total = q(vat_total)
    invoice.total = q(subtotal + vat_total)
    
    session.commit()
    return invoice

def create_credit_note(session: Session, original_invoice_id: str, actor: str = None) -> Invoice:
    orig = session.get(Invoice, original_invoice_id)
    assert orig is not None
    
    if orig.status not in ("SENT", "PAID", "OVERDUE"):
        raise ValueError("Can only create credit note for SENT/PAID/OVERDUE invoices")
    
    shop = session.get(Shop, orig.shop_id)
    number = next_invoice_number(session, shop)
    
    credit = Invoice(
        shop_id=orig.shop_id,
        customer_id=orig.customer_id,
        invoice_number=number,
        status="CREDIT_NOTE",
        issue_date=date.today(),
        due_date=date.today(),
        subtotal=-orig.subtotal,
        vat_total=-orig.vat_total,
        total=-orig.total,
        currency=orig.currency,
        pdf_url=None,
    )
    session.add(credit)
    session.flush()
    
    for orig_item in orig.items:
        ci = InvoiceItem(
            invoice_id=credit.id,
            product_name=orig_item.product_name,
            quantity=-orig_item.quantity,
            unit_price=orig_item.unit_price,
            vat_rate=orig_item.vat_rate,
            total=-orig_item.total,
        )
        session.add(ci)
    
    session.commit()
    return credit

def calculate_vat(payload: dict) -> dict:
    items = payload.get("items") or payload.get("lines") or []
    
    subtotal = Decimal("0.00")
    vat_total = Decimal("0.00")
    
    for it in items:
        qty = int(it.get("qty") or it.get("quantity") or 1)
        unit_price = Decimal(str(it.get("unit_price") or it.get("price") or "0"))
        vat_rate = Decimal(str(it.get("vat_rate") or "0"))
        
        line = q(unit_price) * qty
        
        try:
            shop = payload.get("shop")
            customer = payload.get("customer")
            
            class _Simple:
                def __init__(self, d: dict | None):
                    if not d:
                        self.country = ""
                        self.vat_number = ""
                    else:
                        self.country = d.get("country", "")
                        self.vat_number = d.get("vat_number") or d.get("vatNo") or ""
            
            if isinstance(shop, dict):
                shop = _Simple(shop)
            if isinstance(customer, dict):
                customer = _Simple(customer)
            
            v = compute_vat_for_line(shop, customer, unit_price, qty, vat_rate)
            v = Decimal(str(v))
        except Exception:
            v = q(line * vat_rate / Decimal("100"))
        
        subtotal += line
        vat_total += v
    
    total = q(subtotal + vat_total)
    return {"subtotal": str(q(subtotal)), "vat_total": str(q(vat_total)), "total": str(total)}

================================================================================
FILE: agent.py (390 lines)
================================================================================

[Contains LangChain-based invoice assistant with FAISS vectorstore and various tools]

Key features:
- FAISS vectorstore for document retrieval
- Tools: calculate_vat, query_db, fetch_pdf_hash, check_tx, fetch_invoice, fetch_invoice_full
- VAT calculation integration
- Database query support (read-only)
- PDF hashing with S3/local support
- Blockchain transaction checking (Web3)
- Interactive REPL mode

================================================================================
KEY CONFIGURATION FILES
================================================================================

requirements.txt (Essential dependencies):
- FastAPI
- uvicorn
- SQLAlchemy
- python-jose[cryptography]
- passlib[bcrypt]
- PyJWT
- pydantic
- fpdf2 (for PDF generation)
- boto3 (AWS S3)
- zeep (SOAP for VAT validation)
- langchain
- openai
- faiss-cpu
- web3 (Blockchain)

requirements.prod.txt:
- Production-optimized dependencies for Railway/Docker deployment

================================================================================
DATABASE MODELS SUMMARY
================================================================================

Core entities:
1. Shop - Merchant/seller information with country, VAT, currency settings
2. User - User accounts (admin/staff) with email and role-based access
3. Customer - Buyer records with VAT number and country
4. Product - Sellable items with pricing and VAT rates
5. Invoice - Complete invoice records with status tracking
6. InvoiceItem - Line items on invoices with quantity, price, tax
7. AuditLog - Complete event logging for compliance

================================================================================
AUTHENTICATION & SECURITY
================================================================================

Token-based authentication:
- JWT (JSON Web Tokens) for API access
- OAuth2PasswordBearer for password flow
- Refresh tokens stored in HttpOnly cookies
- API keys with SHA256 hashing
- Bcrypt password hashing (72-byte limit)
- Role-based access control (admin/user)

Endpoints requiring authentication:
- /users
- /invoices
- /merchant/
- /api-keys
- /admin/

================================================================================
INVOICE MANAGEMENT FEATURES
================================================================================

Invoice creation:
- Automatic sequential numbering (e.g., INV-2026-0001)
- VAT calculation based on jurisdiction rules
- PDF generation with international compliance
- Support for B2B reverse charge
- Blockchain transaction tracking
- Multiple payment system support (web2/web3)

PDF Invoice includes:
- Seller and buyer information
- Line items with tax breakdown
- Payment terms and methods
- Bank details or blockchain TX ID
- Tax treatment explanations
- Multi-language support

Credit notes:
- Full and partial refunds
- References to original invoice
- Separate numbering (CN-2026-0001)

================================================================================
PAYMENT INTEGRATION
================================================================================

Supported payment systems:
1. Traditional (web2): Credit card via Stripe
2. Blockchain (web3): Cryptocurrency payments

Webhook handlers for:
- Stripe (payment_intent.succeeded)
- One.com (payment.completed)
- Web3 (blockchain transaction confirmation)

Session-based checkout:
- Create hosted checkout session
- Customer-facing payment UI
- Automatic invoice creation on payment

================================================================================
MERCHANT FEATURES
================================================================================

- Usage statistics (30-day revenue tracking)
- Logo upload and management
- API key generation and revocation
- Session management for payments
- Credit note generation
- VAT validation against EU VIES system

================================================================================
DEPLOYMENT INFORMATION
================================================================================

Production environment:
- Railway platform support with RAILWAY_ENVIRONMENT detection
- Read-only filesystem handling
- Docker containerization support
- Nginx reverse proxy configuration
- Alembic database migrations

Environment variables:
- JWT_SECRET_KEY (required for production)
- DATABASE_URL (for PostgreSQL)
- DATA_DIR (for file persistence, default: /tmp)
- HOSTED_CHECKOUT_BASE (for session URLs)
- ALLOW_DEBUG (enable debug endpoints in non-prod)

================================================================================
FILE PERSISTENCE
================================================================================

For environments without database:
- users.json - User accounts
- invoices.json - Invoice records
- api_keys.json - API key storage
- sessions.json - Checkout session data
- audit.log - Event logs

Threading lock (threading.Lock) prevents concurrent writes in single-process deployment.

================================================================================
ERROR HANDLING & VALIDATION
================================================================================

- Input validation via Pydantic models
- Comprehensive error responses (4xx/5xx HTTP status codes)
- Audit logging of all critical operations
- Brute-force protection (account lockout after 5 failed attempts)
- VAT validation via EU VIES system
- Transaction state machine validation

================================================================================
RATE LIMITING & SECURITY NOTES
================================================================================

- Account lockout: 15 minutes after 5 failed login attempts
- CORS restricted to known frontend origins
- Secure cookies in production (HTTPS only)
- Password enforcement: minimum 6 characters, max 72 bytes (bcrypt)
- API keys: sk_live_ and sk_test_ prefixes for modes

================================================================================
BACKUP GENERATED: 2026-02-13
All source code saved to this file for documentation and recovery purposes.
For latest updates, refer to the Git repository.
================================================================================
